与数组的区别
+ 存储上：连续与非连续
+ 操作上：插入、删除、查询的时间复杂度
+ 缓存上：链表不太适合缓存

特点
+ 结点=（前驱指针）+ data + 后继指针next
+ 头结点
+ 尾结点

分类(要想学会链表必须了解每一种链表的应用场景)
+ 单向链表
+ 双向链表（相比单项，优势在哪）（Java的 LinkedHashMap ）
+ 循环链表（约瑟夫问题）

空间换时间和时间换空间思想
对于执行较慢的程序，可以通过缓存（空间换时间）进行优化；
对于内存消耗过快的程序，可以通过消耗更多时间（时间换空间）进行优化；

应用-LRU淘汰算法
+ 基于链表的基本实现O(n)
+ 散列表+双向列表优化O(1)

思考
+ 为什么说数组使用连续内存存储，更利于CPU的缓存，而链表不需要连续内存存储，则不利于CPU的缓存呢？
> CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中，然后再读到寄存器中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。

+ 如何判断一个字符串是否是回文字符串的问题？如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？

练习题
+ 单链表反转
+ 链表中环的检测
+ 两个有序的链表合并
+ 删除链表倒数第 n 个结点
+ 求链表的中间结点
