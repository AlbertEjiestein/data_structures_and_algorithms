## 02 最好、最坏、平均、均摊时间复杂度



### 01、最好和最坏时间复杂度

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```

上边这段代码的作用是查找一个数组中x的位置。其最好时间复杂度为O(1)，即第一个数就是要查询的值，最坏为O(n)，要么是最后一个值，要么没查到。



### 02、平均时间复杂度

平均时间复杂度的计算需要一定概率论知识，大部分情况下不需要区分最好、最坏和平均这三种情况，使用上一节的判断方法就可以了，只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。



现在计算一下上一段代码的平均时间复杂度，首先有两种情况：找到和没找到，假设概率各位1/2。然后`0 ~ n-1`这n个位置中每种情况的概率为1/n，所以根据概率乘法，任意位置的概率为`1/(2n)`。

![平均时间复杂度计算](/assets/img/平均时间复杂度计算.png)

这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度，故这段代码的加权平均时间复杂度仍然是 O(n)。



### 03、均摊时间复杂度

均摊时间复杂度，可以看作平均时间复杂度的特殊情况，其分析方法为**摊还分析法**。下面看一段代码：

```c
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。



首先，数组的长度为n，对应n种情况，每一种情况的时间复杂度是O(1)，还有一种情况，插入数组的数据超出数组长度时，即`count == array.length`，这个时候时间复杂度为O(n)。对于这`n+1`种情况，每种概率是`1/(n+1)`，根据加权平均的计算方法，求得的平均时间复杂度就是：

![均摊时间复杂度计算](/assets/img/均摊时间复杂度计算.png)



上面的计算是按照平均时间复杂度来计算的，按照摊还分析法如下：

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。



**摊还分析应用场景比较特殊**

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。