### 01 数组（上）-- 对于数组的理解

![数组脑图](/assets/img/数组脑图.png)


#### 01、数组的特点

先理解一下**概念：**数组是一种**线性表**数据结构，他用一组**连续的**内存空间，来存储一组具有相同数据类型的数据。

##### 几个关键词，一个是**线性表**，常见的线性表结构有：**数组，链表、队列、栈**。

![线性表结构](/assets/img/线性表结构.png)

另一个是**非线性表**，比如：**图和树**

![非线性表](/assets/img/非线性表.png)

##### 关于四种常见的线性结构：数组、链表、队列、栈，这里要做一下区别：

数组与链表是描述数据在计算机中**存储方式**的学科。常用的数据存储方式就两种：顺序存储，非顺序存储。前者如数组，后者如链表。

队列和栈是描述对象间**逻辑关系**的学科，队列和栈都可以用数组或链表表示出来。队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构。

##### 在C语言中，数组必须要指定内存大小，这是为什么，而链表为什么不需要？

数组是使用一块连续的内存空间保存数据的，设想一下，有如下代码

```c
int arr[3] = {0};
int i = 0;
```

如果数组不给指定大小为3，因为内存连续的原因，那i的地址到底应该在arr后边多少呢？因为如果数组不固定大小，内存是从起始地址一直往后扩展的，这就导致i的存储地址不固定或者修改arr时导致i的值被修改，这是很混乱的，因此应该刚开始就固定一个数组大小。



#### 02、查找、插入和删除操作

我们在通过数组下表来访问数组元素的时候，是通过寻址公式来计算出对应元素的内存地址的，一维数组的公式如下：

```js
a[i]_address = base_address + i * data_type_size
```

二维数组的公式如下：

```js
对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * type_size
```

**查找操作及其时间复杂度分析**

很多人说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。

实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 

**插入操作及其时间复杂度分析**

对数组插入元素时，考虑三种情况，开头、中间和结尾，如果是前两者，则必须要把后边的数据依次往后移位，后者则不需要。因此时间复杂度分别为O(n)、O(n)和O(1)。

**删除操作及其时间复杂度分析**

数组的删除操作跟插入一样，删除第k个位置时，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。开头、中间和结尾的时间复杂度也分别为O(n)、O(n)和O(1)。

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？

如果多次删除操作，可以先对删除元素做一个标记表示已删除，当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。**其实这就是 JVM 标记清除垃圾回收算法的核心思想。**



#### 03、ArrayList动态扩容

前面说过，数组是一段连续的固定内存大小，那如果元素超出了数组长度，并且没有做防数组越界处理，则会导致意想不到的bug。

针对这种情况，容器可以很好的处理，比如`ArrayList`。**ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容**。

对比数组和`ArrayList`，通常数据很简单或者对性能要求很高，考虑数组，否则可以考虑后者。

在`JavaScript`中，我们通过字面量方式初始化一个数组时（如 var arr = [];），并不需要设置数组大小，这是因为在`JavaScript`中自动帮我们做了数组扩容。

