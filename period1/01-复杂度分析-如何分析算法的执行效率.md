## 01 如何分析算法的执行效率？

### 01、为什么需要复杂度分析（来历）

首先思考一下，数据结构与算法主要是解决什么问题？不禁想到了大跃进时期的一个口号：多快好省。

不过这里的快指的是让代码运行的更快，省指的是更省存储空间。也对应接下来要讲的两种复杂度分析。



复杂度是用来分析**算法执行效率与数据规模**之间的增长关系。这里的算法执行效率也即时间、空间复杂度。



然而，现在通过一些调试工具（比如chrome的调试面板）或者设置埋点等进行统计和监控，可以很容易得到算法执行的时间和占用的内存大小，那为什么还要进行复杂度分析，毕竟逐行代码分析是一个很大的工作量，有必要吗？肯定是有必要的。这种分析方法叫**事后统计法**，也就是我们代码写好以及功能都实现之后，再进行的性能分析，这有时候是不准确的。

+ 测试结果非常依赖测试环境。比如不同的硬件环境其计算能力是不一样的。
+ 测试结果受数据规模的影响很大。比如`JavaScript`中使用`sort`方法排序时，其内部是会对测试数据规模进行判断的，如果数据长度超过10，则使用快速排序，长度小于10时，则使用插入排序。



### 02、大 O 表示法

大O表示法是我们在不运行代码的情况下，评判一段代码时间和空间复杂度的一种方法。

<img src="https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png" alt="img" style="zoom: 50%;" />

T(n) 我们已经讲过了，它表示代码执行的时间或者占用的空间；n 表示数据规模的大小；`f(n)` 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间或者占用的空间 T(n) 与 f(n) 表达式成正比。



看一个例子：

```js
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

我们假设每个语句的执行时间是`unit_time`，则示例的总执行时间`T(n) = (2n^2 + 2n +3) * unit_time`.



### 03、时间复杂度分析

又叫渐进时间复杂度，表示算法的**执行时间和数据规模**之间的关系。

分析时间复杂度只需要关注循环执行次数最多的一段代码，然后使用加法法则和乘法法则即可。



**复杂度量级**

<img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="img" style="zoom:50%;" />



分为 **多项式量级和非多项式量级**：

+ 非多项式量级只有两个：`O(2^n) `和 `O(n!)`

+ 多项式量级，常用如下：
  + `O(1)` ：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
  + `O(logn)、O(nlogn)`：不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。
  + `O(m+n)、O(m*n)`：在无法预估m、n大小的时候使用。



非多项式量级的时间复杂度是非常低效的算法，下面主要介绍多项式时间复杂度：

**1、O(1)**

```JS
int i = 8; // O(1)
int j = 6; // O(1)
int sum = i + j; // O(1)而不是O(3)
```

**2、 O(logn)、O(nlogn)**

```js
i=1;
while (i <= n)  {
  i = i * 2;  // O(log2n)
}
```

```js
i=1;
while (i <= n)  {
  i = i * 3;  // O(log3^n) = O(log3^2 * log2^n) -> O(Clog2n) -> O(log2n)
}
```

**3、O(m+n)、O(m*n)**

```js
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
} // 当无法比较m和n的大小时，时间复杂度为O(m+n)
```



### 04、空间复杂度分析

又叫渐进空间复杂度，表示算法的**存储空间与数据规模**之间的增长关系。

常见的空间复杂度就是 `O(1)、O(n)、O(n2 )`



